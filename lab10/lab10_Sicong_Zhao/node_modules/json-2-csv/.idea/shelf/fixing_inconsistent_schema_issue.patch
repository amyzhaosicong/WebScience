Index: lib/json-2-csv.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/json-2-csv.js	(date 1428541318000)
+++ lib/json-2-csv.js	(revision )
@@ -15,19 +15,23 @@
         return key;
     });
 
-    // TODO: check for consistent schema
-
+    // Check for a consistent schema that does not require the same order:
+    // if we only have one document - then there is no possiblility of multiple schemas
+    if (keys && keys.length <= 1) {
+        return cb(null, _.flatten(keys).join(options.DELIMITER.FIELD));
+    }
+    // else - multiple documents - ensure only one schema (regardless of field ordering)
+    var firstDocSchema = _.flatten(keys[0]);
-    keys = _.map(keys, function(keyList) {
+    keys = _.map(keys, function (keyList) {
+        // If there is a difference between the schemas, throw the inconsistent schema error
+        var diff = _.difference(firstDocSchema, _.flatten(keyList));
+        if (!_.isEqual(diff, [])) {
+            throw new Error('Not all documents have the same schema.', keys);
+        }
         return _.flatten(keyList).join(options.DELIMITER.FIELD);
     });
 
-    // Retrieve the unique array of headings (keys)
-    keys = _.uniq(keys);
-
-    // If we have more than 1 unique list, then not all docs have the same schema - report an error
-    if (keys.length > 1) { throw new Error('Not all documents have the same schema.', keys); }
-
-    return cb(null, keys);
+    return cb(null, [keys[0]]);
 };
 
 // Takes the parent heading and this doc's data and creates the subdocument headings (string)
@@ -52,18 +56,18 @@
 var convertData = function (data, keys) {
     var output = [], // Array of CSV representing converted docs
         value; // Temporary variable to store the current data
-    _.each(keys, function (key, indx) { // For each key
+    _.each(keys, function (key) { // For each key
         value = data[key]; // Set the current data that we are looking at
         if (keys.indexOf(key) > -1) { // If the keys contain the current key, then process the data
             if (_.isArray(value)) { // We have an array of values
-                output.push((options.DELIMITER.WRAP || '') + '[' + value.join(options.DELIMITER.ARRAY) + ']' + (options.DELIMITER.WRAP || ''));
+                output.push(options.DELIMITER.WRAP + '[' + value.join(options.DELIMITER.ARRAY) + ']' + options.DELIMITER.WRAP);
             } else if (_.isDate(value)) { // If we have a date
                 output.push(value.toString());
             } else if (_.isObject(value)) { // If we have an object
                 output.push(convertData(value, _.keys(value))); // Push the recursively generated CSV
             } else {
-                value = value == null ? '' : value.toString();
-                output.push((options.DELIMITER.WRAP || '') + value + (options.DELIMITER.WRAP || '')); // Otherwise push the current value
+                value = value === null ? '' : value.toString();
+                output.push(options.DELIMITER.WRAP + value + options.DELIMITER.WRAP); // Otherwise push the current value
             }
         }
     });
@@ -95,6 +99,7 @@
         async.parallel([_.partial(generateHeading, data), _.partial(generateCsv, data)], function (err, res) {
             if (!err) {
                 // Data received with no errors, join the two responses with an end of line delimiter to setup heading and CSV body
+                console.log(callback, res, options.EOL);
                 return callback(null, res.join(options.EOL));
             } else {
                 return callback(err, null); // Report received error back to caller
